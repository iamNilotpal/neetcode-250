package main

import (
	"strings"
)

// Helper function to generate a frequency string (or "signature") for a given string.
// This signature uniquely represents the character counts of the string,
// making it suitable as a key for grouping anagrams.
func getFrequencyString(str string) string {
	// Intuition 1: Count character frequencies.
	// Since we're dealing with lowercase English letters ('a' through 'z'),
	// an array of 26 integers is perfect for storing their counts.
	// `charFrequency[0]` will store count of 'a', `charFrequency[1]` for 'b', etc.
	charFrequency := make([]int, 26)

	// Iterate through each character in the input string 'str'.
	for _, char := range str {
		// Calculate the index for the character: `int(char - 'a')` converts 'a' to 0, 'b' to 1, etc.
		index := int(char - 'a')
		// Increment the count for that character at its corresponding index.
		charFrequency[index]++
	}

	// Intuition 2: Construct a unique string representation from the frequencies.
	// This "frequency string" will act as the key in our main map.
	// It must be unique for each combination of character counts.
	var builder strings.Builder

	// `char` is used to reconstruct the character ('a', 'b', etc.) to append to the signature.
	char := 'a'
	// Iterate through the `charFrequency` array (from 'a' to 'z').
	for _, v := range charFrequency {
		// Append the character itself (e.g., 'a', 'b', 'c').
		builder.WriteRune(char)
		// Append its count. Directly appending `int` will convert it to its ASCII byte representation.
		builder.WriteByte(byte(v)) // This will append the raw byte value of the frequency.
		char++                     // Move to the next character ('b', 'c', etc.).
	}

	return builder.String()
}

func groupAnagramsSol2(strs []string) [][]string {
	// Intuition 1: Handle Edge Cases
	// Same as Solution 1: If there's 0 or 1 string, return it as is.
	if len(strs) <= 1 {
		return [][]string{strs}
	}

	// Intuition 2: Use a Hash Map for Grouping
	// The map's key will be the `frequency string` generated by `getFrequencyString`,
	// and the value will be a slice of original strings that produce that frequency string.
	frequency := make(map[string][]string)

	// Intuition 3: Iterate and Populate the Map
	// For each string `str` in the input slice `strs`:
	for _, str := range strs {
		// Generate the unique "frequency signature" for the current string.
		strFrequency := getFrequencyString(str) // Calls the helper function.

		// Append the original string `str` to the list associated with its frequency signature.
		// If the signature is new, a new slice is implicitly created for it.
		frequency[strFrequency] = append(frequency[strFrequency], str)
	}

	// Intuition 4: Extract Groups from the Map
	// Initialize the result slice. Pre-allocating capacity can be a minor optimization.
	ans := make([][]string, 0, len(frequency))
	// Iterate through the values of the `frequency` map. Each value is a `[]string`
	// representing a group of anagrams.
	for _, v := range frequency {
		ans = append(ans, v)
	}

	return ans
}
